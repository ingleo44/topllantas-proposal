---
layout: default
title: "Integraci√≥n con tu ERP"
description: "C√≥mo TopLlantas AI se conecta perfectamente con tus sistemas actuales"
---

# üîó Integraci√≥n TopLlantas AI con tu ERP
## Conecta Todo Sin Cambiar lo que ya Funciona

> **La integraci√≥n m√°s importante: hacer que tu ERP actual y los nuevos agentes de IA trabajen juntos como un solo sistema, sin interrumpir tu operaci√≥n diaria.**

---

## üéØ ¬øPor Qu√© es Importante la Integraci√≥n?

### Problemas Comunes Sin Integraci√≥n
- ‚ùå **Entrada doble de datos** (ERP + sistema nuevo)
- ‚ùå **Informaci√≥n desactualizada** entre sistemas
- ‚ùå **Errores humanos** al transferir datos
- ‚ùå **Tiempo perdido** sincronizando manualmente
- ‚ùå **Resistencia del equipo** a usar m√∫ltiples sistemas

### Beneficios de Integraci√≥n Completa
- ‚úÖ **Un solo punto de verdad** para todos los datos
- ‚úÖ **Sincronizaci√≥n autom√°tica** en tiempo real
- ‚úÖ **Cero trabajo manual** adicional
- ‚úÖ **Tu equipo sigue trabajando** igual que siempre
- ‚úÖ **Los agentes IA acceden** a informaci√≥n actualizada

---

## üîß C√≥mo Funciona la Integraci√≥n

### Proceso Simple y Transparente

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   üìä Tu ERP     ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ  üîó Conectores  ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ ü§ñ Agentes IA   ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ   Inteligentes  ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ ‚Ä¢ Inventario    ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ ‚Ä¢ Ventas 24/7   ‚îÇ
‚îÇ ‚Ä¢ Ventas        ‚îÇ    ‚îÇ ‚Ä¢ Seguridad     ‚îÇ    ‚îÇ ‚Ä¢ Predicciones  ‚îÇ
‚îÇ ‚Ä¢ Clientes      ‚îÇ    ‚îÇ ‚Ä¢ Tiempo real   ‚îÇ    ‚îÇ ‚Ä¢ Optimizaci√≥n  ‚îÇ
‚îÇ ‚Ä¢ Proveedores   ‚îÇ    ‚îÇ ‚Ä¢ Bidireccional ‚îÇ    ‚îÇ ‚Ä¢ Automatizaci√≥n‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                       ‚îÇ                       ‚îÇ
         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚îÇ üõ°Ô∏è Seguridad    ‚îÇ
                    ‚îÇ   y Backup      ‚îÇ
                    ‚îÇ                 ‚îÇ
                    ‚îÇ ‚Ä¢ Encriptaci√≥n  ‚îÇ
                    ‚îÇ ‚Ä¢ Auditor√≠a     ‚îÇ
                    ‚îÇ ‚Ä¢ Respaldos     ‚îÇ
                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Compatibilidad Universal
Trabajamos con cualquier ERP:
- **SAP** (Business One, S/4HANA)
- **Oracle** (NetSuite, JD Edwards)  
- **Microsoft Dynamics** (365, AX, NAV)
- **ERPs Mexicanos** (COI, Aspel, Contpaq)
- **Sistemas Custom** o desarrollos internos
- **Bases de datos** (SQL Server, MySQL, Oracle)

---

## üìã Proceso de Integraci√≥n Paso a Paso

### Fase 1: An√°lisis y Planeaci√≥n (Semana 1)

**Lo que Hacemos**
- üîç **An√°lisis completo** de tu ERP actual
- üìä **Mapeo de datos** y procesos existentes
- üéØ **Identificaci√≥n de puntos** de integraci√≥n cr√≠ticos
- üìã **Plan detallado** de implementaci√≥n
- ‚ö†Ô∏è **Identificaci√≥n de riesgos** y mitigaci√≥n

**Lo que Necesitamos de Ti**
- Acceso de solo lectura a la base de datos
- 2-3 horas de tu equipo t√©cnico para explicar procesos
- Documentaci√≥n del ERP (si est√° disponible)

**Entregables**
- Documento de arquitectura de integraci√≥n
- Plan de implementaci√≥n detallado
- Cronograma espec√≠fico con hitos
- Estrategia de backup y seguridad

### Fase 2: Desarrollo de Conectores (Semanas 2-4)

**Conectores que Desarrollamos**

**üì¶ Conector de Inventario**
- Sincronizaci√≥n de productos y stock
- Alertas autom√°ticas de cambios
- Historial de movimientos
- Categor√≠as y clasificaciones

**üíº Conector de Ventas**  
- Clientes y prospectos
- Historial de compras
- Precios y descuentos
- T√©rminos de pago

**üöö Conector de Log√≠stica**
- √ìrdenes de compra
- Proveedores y t√©rminos
- Entregas y tracking
- Costos de transporte

**üìä Conector de Reportes**
- M√©tricas en tiempo real
- KPIs personalizados
- Dashboards ejecutivos
- Alertas inteligentes

### Fase 3: Pruebas y Validaci√≥n (Semana 5)

**Proceso de Pruebas Riguroso**
- ‚úÖ **Pruebas en ambiente de desarrollo** (sin afectar producci√≥n)
- ‚úÖ **Validaci√≥n de datos** (precisi√≥n 100%)
- ‚úÖ **Pruebas de performance** (velocidad √≥ptima)
- ‚úÖ **Pruebas de seguridad** (encriptaci√≥n completa)
- ‚úÖ **Simulaci√≥n de fallos** (recuperaci√≥n autom√°tica)

**Validaci√≥n con tu Equipo**
- Demo funcional completa
- Revisi√≥n de todos los procesos
- Validaci√≥n de reportes y m√©tricas
- Aprobaci√≥n final antes del go-live

### Fase 4: Implementaci√≥n en Producci√≥n (Semana 6)

**Go-Live Sin Interrupciones**
- üïê **Implementaci√≥n fuera de horas** laborales
- üîÑ **Migraci√≥n gradual** de datos
- üìû **Soporte 24/7** durante la primera semana
- üõ°Ô∏è **Backup completo** antes de cualquier cambio
- ‚ö° **Rollback inmediato** si hay alg√∫n problema

---

## üõ°Ô∏è Seguridad y Confiabilidad

### Medidas de Seguridad Implementadas

**Protecci√≥n de Datos**
- üîê **Encriptaci√≥n AES-256** en tr√°nsito y reposo
- üîë **Autenticaci√≥n multifactor** para todos los accesos
- üõ°Ô∏è **Firewall dedicado** para conexiones ERP
- üìä **Auditor√≠a completa** de todos los accesos
- üïê **Logs detallados** de todas las transacciones

**Backup y Recuperaci√≥n**
- ‚òÅÔ∏è **Backup autom√°tico** cada 4 horas en Azure
- üíæ **Backup local** diario en tu infraestructura
- üîÑ **Recuperaci√≥n ante desastres** en menos de 2 horas
- üìã **Plan de continuidad** documentado y probado
- üß™ **Pruebas de recuperaci√≥n** mensuales

**Compliance y Certificaciones**
- üìú **ISO 27001** compliance para seguridad
- üèõÔ∏è **SOC 2 Type II** para confiabilidad
- üá≤üáΩ **Cumplimiento fiscal** mexicano (SAT)
- üìä **GDPR compliance** para protecci√≥n de datos
- üîç **Auditor√≠as externas** anuales

---

## üìä Monitoreo en Tiempo Real

### Dashboard de Integraci√≥n
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ üîó ESTADO DE INTEGRACI√ìN ERP - TIEMPO REAL                 ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                             ‚îÇ
‚îÇ üü¢ CONEXIONES ACTIVAS                                      ‚îÇ
‚îÇ ‚Ä¢ ERP Database: ‚úÖ Online (latencia: 12ms)                 ‚îÇ
‚îÇ ‚Ä¢ Agente Ventas: ‚úÖ Sincronizado (√∫ltimo: 14:32)          ‚îÇ
‚îÇ ‚Ä¢ Agente Inventario: ‚úÖ Activo (√∫ltimo: 14:33)            ‚îÇ
‚îÇ ‚Ä¢ Agente Log√≠stica: ‚úÖ Funcionando (√∫ltimo: 14:31)        ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ üìä SINCRONIZACI√ìN HOY                                      ‚îÇ
‚îÇ ‚Ä¢ Productos actualizados: 1,247                            ‚îÇ
‚îÇ ‚Ä¢ Ventas procesadas: 89                                    ‚îÇ
‚îÇ ‚Ä¢ √ìrdenes sincronizadas: 23                                ‚îÇ
‚îÇ ‚Ä¢ Alertas enviadas: 7                                      ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ ‚ö° PERFORMANCE                                              ‚îÇ
‚îÇ ‚Ä¢ Tiempo respuesta promedio: 180ms                         ‚îÇ
‚îÇ ‚Ä¢ Uptime: 99.97% (este mes)                               ‚îÇ
‚îÇ ‚Ä¢ Transacciones/minuto: 145                               ‚îÇ
‚îÇ ‚Ä¢ Errores: 0 (√∫ltimas 24h)                                ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ üîî PR√ìXIMAS SINCRONIZACIONES                               ‚îÇ
‚îÇ ‚Ä¢ Inventario completo: 18:00 (diario)                     ‚îÇ
‚îÇ ‚Ä¢ Backup completo: 02:00 (diario)                         ‚îÇ
‚îÇ ‚Ä¢ Reporte semanal: Lunes 08:00                            ‚îÇ
‚îÇ                                                             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üöÄ Casos de Uso Reales de Integraci√≥n

### Caso 1: Venta Autom√°tica Nocturna

**Escenario**: Cliente solicita cotizaci√≥n a las 11:30 PM

1. **Cliente escribe**: "Necesito 4 llantas Michelin 205/55R16"
2. **Agente IA consulta ERP**: Stock disponible, precios actuales, descuentos
3. **Genera cotizaci√≥n**: Precios personalizados seg√∫n historial del cliente
4. **Cliente acepta**: Agente crea orden autom√°ticamente en ERP
5. **Confirmaci√≥n inmediata**: Cliente recibe confirmaci√≥n y n√∫mero de orden
6. **Al d√≠a siguiente**: Vendedor encuentra la orden ya capturada en el ERP

**Resultado**: Venta cerrada fuera de horario, sin intervenci√≥n humana, todo registrado correctamente en el ERP.

### Caso 2: Alerta Autom√°tica de Inventario

**Escenario**: Stock cr√≠tico detectado autom√°ticamente

1. **Agente Inventario detecta**: Llanta popular llegando a m√≠nimo
2. **Consulta ERP**: Historial de ventas, proveedores, t√©rminos
3. **Calcula orden √≥ptima**: Cantidad, timing, proveedor preferido
4. **Alerta al comprador**: WhatsApp con recomendaci√≥n espec√≠fica
5. **Un clic para ordenar**: Comprador aprueba desde el m√≥vil
6. **Orden autom√°tica**: Se genera PO en el ERP autom√°ticamente

**Resultado**: Nunca m√°s faltantes cr√≠ticos, inventario optimizado, proceso sin fricci√≥n.

### Caso 3: Optimizaci√≥n de Entregas

**Escenario**: M√∫ltiples entregas programadas para ma√±ana

1. **Agente Log√≠stica consulta ERP**: Pedidos confirmados para ma√±ana
2. **Calcula rutas √≥ptimas**: Considerando tr√°fico y ventanas de entrega
3. **Asigna veh√≠culos**: Basado en capacidad y ubicaci√≥n
4. **Notifica a clientes**: WhatsApp con horario confirmado
5. **Actualiza ERP**: Tracking numbers y rutas programadas
6. **Seguimiento en vivo**: Actualizaciones autom√°ticas de status

**Resultado**: 40% menos costo de entrega, 95% entregas a tiempo, clientes informados siempre.

---

## üí∞ Inversi√≥n en Integraci√≥n

### ¬øQu√© Incluye el Costo de Integraci√≥n?

**Incluido en los $125,000 del Proyecto**
- ‚úÖ **An√°lisis completo** de tu ERP actual
- ‚úÖ **Desarrollo de conectores** espec√≠ficos para tu sistema
- ‚úÖ **Migraci√≥n segura** de datos hist√≥ricos
- ‚úÖ **Pruebas exhaustivas** en ambiente de desarrollo
- ‚úÖ **Implementaci√≥n sin downtime** en producci√≥n
- ‚úÖ **Capacitaci√≥n completa** del equipo
- ‚úÖ **Soporte 24/7** durante primer mes
- ‚úÖ **Garant√≠a de funcionamiento** por 12 meses

**Sin Costos Adicionales Por**
- ‚ùå **Cambios en scope** razonables durante desarrollo
- ‚ùå **Ajustes menores** en la l√≥gica de negocio
- ‚ùå **Capacitaci√≥n adicional** si es necesaria
- ‚ùå **Soporte durante** el per√≠odo de garant√≠a
- ‚ùå **Actualizaciones** del conector por cambios en ERP

### Comparaci√≥n con Otras Opciones

**Desarrollo Interno**
- üí∞ **Costo**: $180,000 - $250,000
- ‚è∞ **Tiempo**: 12-18 meses
- üéØ **Riesgo**: Alto (falta de experiencia)
- üõ†Ô∏è **Mantenimiento**: Tu responsabilidad

**Empresa Grande de Software**
- üí∞ **Costo**: $300,000 - $500,000
- ‚è∞ **Tiempo**: 18-24 meses
- üéØ **Personalizaci√≥n**: Limitada
- üìû **Soporte**: Costoso y lento

**Nuestra Propuesta TopLlantas AI**
- üí∞ **Costo**: $125,000 (todo incluido)
- ‚è∞ **Tiempo**: 8 meses
- üéØ **Personalizaci√≥n**: Completa
- üìû **Soporte**: Directo y personal

---

## üîÆ Futuro de la Integraci√≥n

### Escalabilidad Garantizada

**Preparado Para Crecer**
- üè¢ **M√∫ltiples sucursales**: F√°cil replicaci√≥n del modelo
- üìà **Mayor volumen**: Arquitectura que escala autom√°ticamente
- üîå **Nuevos sistemas**: Conectores adicionales sin reestructurar
- üåê **Expansi√≥n geogr√°fica**: Cloud native para cualquier ubicaci√≥n

**Evoluci√≥n Continua**
- ü§ñ **Nuevos agentes IA**: Se integran autom√°ticamente
- üìä **Mejores insights**: An√°lisis m√°s profundos con m√°s datos
- ‚ö° **Optimizaciones**: Performance mejorado constantemente
- üîÑ **Actualizaciones**: Sin interrumpir la operaci√≥n

---

## ‚úÖ Garant√≠as de Integraci√≥n

### Nuestros Compromisos Espec√≠ficos

**Garant√≠a T√©cnica**
- ‚úÖ **100% de datos migrados** correctamente
- ‚úÖ **Zero downtime** durante implementaci√≥n
- ‚úÖ **Performance igual o mejor** que sistema actual
- ‚úÖ **Rollback completo** disponible por 30 d√≠as

**Garant√≠a de Negocio**
- ‚úÖ **Productividad mantenida** durante transici√≥n
- ‚úÖ **Capacitaci√≥n hasta** que equipo est√© c√≥modo
- ‚úÖ **Soporte prioritario** primer a√±o incluido
- ‚úÖ **Ajustes sin costo** los primeros 6 meses

**Garant√≠a de Satisfacci√≥n**
- ‚úÖ **30 d√≠as** para evaluar completamente
- ‚úÖ **Reembolso total** si no cumple expectativas
- ‚úÖ **Comunicaci√≥n directa** con el desarrollador siempre
- ‚úÖ **Transparencia total** en el proceso

---

## üìû Pr√≥ximo Paso: Demo de Integraci√≥n

### ¬øQuieres Ver C√≥mo Funciona?

**Demo Personalizada (45 minutos)**
1. **Conectamos** temporalmente con tu ERP (solo lectura)
2. **Mostramos** agente IA consultando datos reales
3. **Demostramos** sincronizaci√≥n en tiempo real
4. **Respondemos** todas tus preguntas t√©cnicas
5. **Definimos** plan espec√≠fico para tu empresa

**Qu√© Necesitamos Para la Demo**
- 1 hora de tu equipo t√©cnico
- Acceso temporal de solo lectura a base de datos
- Lista de procesos cr√≠ticos que quieres ver automatizados

**¬øCu√°ndo Podemos Hacerla?**
- Disponible esta misma semana
- Virtual o presencial (tu prefieras)
- Sin compromiso, solo informaci√≥n valiosa

---

*La integraci√≥n perfecta no es casualidad... es ingenier√≠a inteligente.*

**¬øListo para ver tu ERP y los agentes IA trabajando como uno solo?**

---

## Arquitectura de APIs

### Dise√±o de Alto Nivel

```mermaid
graph TB
    subgraph "External Clients"
        WEB[Portal Web]
        MOB[Mobile App]
        AGENTS[AI Agents]
        EXT[External Partners]
    end
    
    subgraph "API Gateway Layer"
        APIM[Azure API Management]
        OAUTH[OAuth 2.0 Gateway]
        RATE[Rate Limiting]
        CACHE[Response Caching]
    end
    
    subgraph "Microservices Layer"
        ERP_API[ERP Integration API]
        PROD_API[Product Catalog API]
        INV_API[Inventory API]
        ORDER_API[Order Management API]
        CUST_API[Customer Management API]
        ANALYTICS_API[Analytics API]
    end
    
    subgraph "Data Layer"
        ERP_DB[(ERP Database)]
        COSMOS[(Cosmos DB)]
        SQL[(Azure SQL)]
        CACHE_DB[(Redis Cache)]
    end
    
    WEB --> APIM
    MOB --> APIM
    AGENTS --> APIM
    EXT --> APIM
    
    APIM --> OAUTH
    OAUTH --> RATE
    RATE --> CACHE
    
    CACHE --> ERP_API
    CACHE --> PROD_API
    CACHE --> INV_API
    CACHE --> ORDER_API
    CACHE --> CUST_API
    CACHE --> ANALYTICS_API
    
    ERP_API --> ERP_DB
    PROD_API --> COSMOS
    INV_API --> SQL
    ORDER_API --> SQL
    CUST_API --> COSMOS
    ANALYTICS_API --> CACHE_DB
```

---

## API Core: ERP Integration Service

### Arquitectura del Servicio

```csharp
[ApiController]
[Route("api/v1/erp")]
[Authorize]
public class ERPIntegrationController : ControllerBase
{
    private readonly IERPService _erpService;
    private readonly IMapper _mapper;
    private readonly ILogger<ERPIntegrationController> _logger;
    private readonly ICacheService _cache;

    public ERPIntegrationController(
        IERPService erpService,
        IMapper mapper,
        ILogger<ERPIntegrationController> logger,
        ICacheService cache)
    {
        _erpService = erpService;
        _mapper = mapper;
        _logger = logger;
        _cache = cache;
    }

    /// <summary>
    /// Sincronizar productos desde ERP
    /// </summary>
    [HttpPost("sync/products")]
    [SwaggerOperation(Summary = "Sincronizar cat√°logo de productos desde ERP")]
    [SwaggerResponse(200, "Sincronizaci√≥n exitosa", typeof(SyncResult))]
    [SwaggerResponse(429, "Rate limit excedido")]
    public async Task<ActionResult<SyncResult>> SyncProductsAsync(
        [FromBody] SyncRequest request)
    {
        try
        {
            _logger.LogInformation(
                "Iniciando sincronizaci√≥n de productos. Filtros: {Filters}", 
                request.Filters);

            var erpProducts = await _erpService.GetProductsAsync(request.Filters);
            var mappedProducts = _mapper.Map<List<ProductDto>>(erpProducts);
            
            var syncResult = await _erpService.SyncProductsAsync(mappedProducts);
            
            // Invalidar cache de productos
            await _cache.RemoveByPatternAsync("products:*");
            
            _logger.LogInformation(
                "Sincronizaci√≥n completada. {Count} productos procesados", 
                syncResult.ProcessedCount);

            return Ok(syncResult);
        }
        catch (ERPConnectionException ex)
        {
            _logger.LogError(ex, "Error de conexi√≥n con ERP");
            return StatusCode(502, new { Error = "ERP connection failed", Details = ex.Message });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error inesperado durante sincronizaci√≥n");
            return StatusCode(500, new { Error = "Internal server error" });
        }
    }

    /// <summary>
    /// Obtener inventario en tiempo real
    /// </summary>
    [HttpGet("inventory/{productId}")]
    [SwaggerOperation(Summary = "Obtener niveles de inventario por producto")]
    [SwaggerResponse(200, "Inventario encontrado", typeof(InventoryDto))]
    [SwaggerResponse(404, "Producto no encontrado")]
    [ProducesResponseType(typeof(InventoryDto), 200)]
    public async Task<ActionResult<InventoryDto>> GetInventoryAsync(
        string productId,
        [FromQuery] string? warehouse = null)
    {
        var cacheKey = $"inventory:{productId}:{warehouse ?? "all"}";
        
        // Intentar obtener del cache primero
        var cachedInventory = await _cache.GetAsync<InventoryDto>(cacheKey);
        if (cachedInventory != null)
        {
            return Ok(cachedInventory);
        }

        var inventory = await _erpService.GetInventoryAsync(productId, warehouse);
        
        if (inventory == null)
        {
            return NotFound(new { Message = $"Product {productId} not found" });
        }

        var inventoryDto = _mapper.Map<InventoryDto>(inventory);
        
        // Cache por 5 minutos
        await _cache.SetAsync(cacheKey, inventoryDto, TimeSpan.FromMinutes(5));
        
        return Ok(inventoryDto);
    }

    /// <summary>
    /// Crear orden en ERP
    /// </summary>
    [HttpPost("orders")]
    [SwaggerOperation(Summary = "Crear nueva orden en sistema ERP")]
    [SwaggerResponse(201, "Orden creada exitosamente", typeof(OrderResponseDto))]
    [SwaggerResponse(400, "Datos de orden inv√°lidos")]
    public async Task<ActionResult<OrderResponseDto>> CreateOrderAsync(
        [FromBody] CreateOrderRequest request)
    {
        try
        {
            // Validar datos de entrada
            var validationResult = await ValidateOrderRequestAsync(request);
            if (!validationResult.IsValid)
            {
                return BadRequest(validationResult.Errors);
            }

            // Verificar disponibilidad de inventario
            var inventoryCheck = await _erpService.CheckInventoryAvailabilityAsync(
                request.Items);
            
            if (!inventoryCheck.IsAvailable)
            {
                return BadRequest(new 
                { 
                    Error = "Insufficient inventory", 
                    UnavailableItems = inventoryCheck.UnavailableItems 
                });
            }

            // Crear orden en ERP
            var erpOrder = _mapper.Map<ERPOrder>(request);
            var createdOrder = await _erpService.CreateOrderAsync(erpOrder);
            
            var response = _mapper.Map<OrderResponseDto>(createdOrder);
            
            _logger.LogInformation(
                "Orden creada exitosamente. OrderId: {OrderId}, Total: {Total}", 
                response.OrderId, response.Total);

            return CreatedAtAction(
                nameof(GetOrderAsync), 
                new { orderId = response.OrderId }, 
                response);
        }
        catch (InsufficientInventoryException ex)
        {
            return BadRequest(new { Error = "Insufficient inventory", Details = ex.Message });
        }
        catch (ERPValidationException ex)
        {
            return BadRequest(new { Error = "ERP validation failed", Details = ex.Message });
        }
    }
}
```

### Implementaci√≥n del Servicio ERP

```csharp
public class ERPService : IERPService
{
    private readonly HttpClient _httpClient;
    private readonly IConfiguration _configuration;
    private readonly ILogger<ERPService> _logger;
    private readonly IResilientHttpClient _resilientClient;

    public ERPService(
        HttpClient httpClient,
        IConfiguration configuration,
        ILogger<ERPService> logger,
        IResilientHttpClient resilientClient)
    {
        _httpClient = httpClient;
        _configuration = configuration;
        _logger = logger;
        _resilientClient = resilientClient;
    }

    public async Task<List<ERPProduct>> GetProductsAsync(ProductFilters? filters = null)
    {
        var endpoint = BuildProductsEndpoint(filters);
        
        var response = await _resilientClient.GetAsync(endpoint);
        response.EnsureSuccessStatusCode();
        
        var content = await response.Content.ReadAsStringAsync();
        var erpResponse = JsonSerializer.Deserialize<ERPProductResponse>(content);
        
        return erpResponse.Products;
    }

    public async Task<ERPInventory?> GetInventoryAsync(string productId, string? warehouse = null)
    {
        var endpoint = $"/api/inventory/{productId}";
        if (!string.IsNullOrEmpty(warehouse))
        {
            endpoint += $"?warehouse={warehouse}";
        }

        try
        {
            var response = await _resilientClient.GetAsync(endpoint);
            
            if (response.StatusCode == HttpStatusCode.NotFound)
            {
                return null;
            }
            
            response.EnsureSuccessStatusCode();
            
            var content = await response.Content.ReadAsStringAsync();
            return JsonSerializer.Deserialize<ERPInventory>(content);
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "Error fetching inventory for product {ProductId}", productId);
            throw new ERPConnectionException($"Failed to fetch inventory for {productId}", ex);
        }
    }

    public async Task<ERPOrder> CreateOrderAsync(ERPOrder order)
    {
        var jsonContent = JsonSerializer.Serialize(order);
        var httpContent = new StringContent(jsonContent, Encoding.UTF8, "application/json");
        
        try
        {
            var response = await _resilientClient.PostAsync("/api/orders", httpContent);
            response.EnsureSuccessStatusCode();
            
            var responseContent = await response.Content.ReadAsStringAsync();
            var createdOrder = JsonSerializer.Deserialize<ERPOrder>(responseContent);
            
            return createdOrder;
        }
        catch (HttpRequestException ex)
        {
            _logger.LogError(ex, "Error creating order in ERP");
            throw new ERPConnectionException("Failed to create order in ERP", ex);
        }
    }
}
```

### Cliente HTTP Resiliente

```csharp
public class ResilientHttpClient : IResilientHttpClient
{
    private readonly HttpClient _httpClient;
    private readonly IAsyncPolicy<HttpResponseMessage> _retryPolicy;
    private readonly ILogger<ResilientHttpClient> _logger;

    public ResilientHttpClient(
        HttpClient httpClient,
        ILogger<ResilientHttpClient> logger)
    {
        _httpClient = httpClient;
        _logger = logger;
        
        // Configurar pol√≠tica de reintentos con backoff exponencial
        _retryPolicy = Policy
            .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode)
            .Or<HttpRequestException>()
            .Or<TaskCanceledException>()
            .WaitAndRetryAsync(
                retryCount: 3,
                sleepDurationProvider: retryAttempt => 
                    TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + 
                    TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000)),
                onRetry: (outcome, timespan, retryCount, context) =>
                {
                    _logger.LogWarning(
                        "Retry {RetryCount} for request after {Delay}ms. Reason: {Reason}",
                        retryCount, timespan.TotalMilliseconds, 
                        outcome.Exception?.Message ?? outcome.Result?.StatusCode.ToString());
                });
    }

    public async Task<HttpResponseMessage> GetAsync(string endpoint)
    {
        return await _retryPolicy.ExecuteAsync(async () =>
        {
            _logger.LogDebug("Making GET request to {Endpoint}", endpoint);
            return await _httpClient.GetAsync(endpoint);
        });
    }

    public async Task<HttpResponseMessage> PostAsync(string endpoint, HttpContent content)
    {
        return await _retryPolicy.ExecuteAsync(async () =>
        {
            _logger.LogDebug("Making POST request to {Endpoint}", endpoint);
            return await _httpClient.PostAsync(endpoint, content);
        });
    }
}
```

---

## API de Gesti√≥n de Productos

### Controlador Principal

```csharp
[ApiController]
[Route("api/v1/products")]
[Authorize]
public class ProductsController : ControllerBase
{
    private readonly IProductService _productService;
    private readonly IMapper _mapper;
    private readonly ILogger<ProductsController> _logger;

    /// <summary>
    /// Buscar productos con filtros avanzados
    /// </summary>
    [HttpGet("search")]
    [SwaggerOperation(Summary = "Buscar productos con filtros avanzados")]
    [SwaggerResponse(200, "Productos encontrados", typeof(PagedResult<ProductDto>))]
    public async Task<ActionResult<PagedResult<ProductDto>>> SearchProductsAsync(
        [FromQuery] ProductSearchRequest request)
    {
        var searchCriteria = _mapper.Map<ProductSearchCriteria>(request);
        var products = await _productService.SearchProductsAsync(searchCriteria);
        
        var response = _mapper.Map<PagedResult<ProductDto>>(products);
        
        // Agregar headers de paginaci√≥n
        Response.Headers.Add("X-Total-Count", products.TotalCount.ToString());
        Response.Headers.Add("X-Page-Count", products.PageCount.ToString());
        
        return Ok(response);
    }

    /// <summary>
    /// Obtener recomendaciones de productos basadas en AI
    /// </summary>
    [HttpGet("{productId}/recommendations")]
    [SwaggerOperation(Summary = "Obtener productos recomendados usando AI")]
    [SwaggerResponse(200, "Recomendaciones encontradas", typeof(List<ProductRecommendationDto>))]
    public async Task<ActionResult<List<ProductRecommendationDto>>> GetRecommendationsAsync(
        string productId,
        [FromQuery] string? customerId = null,
        [FromQuery] int limit = 5)
    {
        var recommendations = await _productService.GetAIRecommendationsAsync(
            productId, customerId, limit);
        
        var response = _mapper.Map<List<ProductRecommendationDto>>(recommendations);
        
        return Ok(response);
    }

    /// <summary>
    /// Verificar compatibilidad de productos
    /// </summary>
    [HttpPost("compatibility-check")]
    [SwaggerOperation(Summary = "Verificar compatibilidad entre productos")]
    [SwaggerResponse(200, "Resultado de compatibilidad", typeof(CompatibilityResultDto))]
    public async Task<ActionResult<CompatibilityResultDto>> CheckCompatibilityAsync(
        [FromBody] CompatibilityCheckRequest request)
    {
        var result = await _productService.CheckCompatibilityAsync(
            request.ProductIds, request.VehicleSpecs);
        
        var response = _mapper.Map<CompatibilityResultDto>(result);
        
        return Ok(response);
    }
}
```

### Servicio de Productos con AI

```csharp
public class ProductService : IProductService
{
    private readonly IProductRepository _repository;
    private readonly IAzureOpenAIService _openAI;
    private readonly IVectorSearchService _vectorSearch;
    private readonly ICacheService _cache;

    public async Task<List<ProductRecommendation>> GetAIRecommendationsAsync(
        string productId, string? customerId = null, int limit = 5)
    {
        var cacheKey = $"recommendations:{productId}:{customerId}:{limit}";
        
        // Verificar cache primero
        var cached = await _cache.GetAsync<List<ProductRecommendation>>(cacheKey);
        if (cached != null)
        {
            return cached;
        }

        // Obtener producto base
        var baseProduct = await _repository.GetByIdAsync(productId);
        if (baseProduct == null)
        {
            throw new ProductNotFoundException(productId);
        }

        // Obtener historial del cliente si est√° disponible
        CustomerProfile? customerProfile = null;
        if (!string.IsNullOrEmpty(customerId))
        {
            customerProfile = await GetCustomerProfileAsync(customerId);
        }

        // Generar embeddings del producto base
        var productEmbedding = await _openAI.GenerateEmbeddingAsync(
            $"{baseProduct.Brand} {baseProduct.Model} {baseProduct.Category} {baseProduct.Specifications}");

        // B√∫squeda vectorial de productos similares
        var similarProducts = await _vectorSearch.SearchSimilarAsync(
            productEmbedding, limit * 3); // Obtener m√°s para filtrar

        // Aplicar filtros de negocio
        var filteredProducts = ApplyBusinessFilters(similarProducts, baseProduct, customerProfile);

        // Aplicar AI scoring para ranking final
        var recommendations = await GenerateAIScoredRecommendationsAsync(
            baseProduct, filteredProducts, customerProfile, limit);

        // Cache por 1 hora
        await _cache.SetAsync(cacheKey, recommendations, TimeSpan.FromHours(1));

        return recommendations;
    }

    private async Task<List<ProductRecommendation>> GenerateAIScoredRecommendationsAsync(
        Product baseProduct, 
        List<Product> candidates, 
        CustomerProfile? customerProfile, 
        int limit)
    {
        var recommendations = new List<ProductRecommendation>();

        foreach (var candidate in candidates)
        {
            var prompt = $@"
            Analiza la siguiente recomendaci√≥n de producto para TopLlantas:

            Producto Base:
            - Marca: {baseProduct.Brand}
            - Modelo: {baseProduct.Model}
            - Categor√≠a: {baseProduct.Category}
            - Precio: ${baseProduct.Price}
            
            Producto Candidato:
            - Marca: {candidate.Brand}
            - Modelo: {candidate.Model}
            - Categor√≠a: {candidate.Category}
            - Precio: ${candidate.Price}
            
            {(customerProfile != null ? $@"
            Perfil del Cliente:
            - Tipo: {customerProfile.Type}
            - Historial: {string.Join(", ", customerProfile.PreviousPurchases)}
            - Presupuesto promedio: ${customerProfile.AverageBudget}
            " : "")}
            
            Califica esta recomendaci√≥n del 0 al 100 considerando:
            1. Compatibilidad t√©cnica
            2. Relaci√≥n calidad-precio
            3. Relevancia para el cliente
            4. Popularidad en el mercado
            
            Responde solo con el n√∫mero de la calificaci√≥n.
            ";

            var scoreResponse = await _openAI.GenerateCompletionAsync(prompt, new
            {
                MaxTokens = 10,
                Temperature = 0.1
            });

            if (int.TryParse(scoreResponse.Text.Trim(), out var score))
            {
                recommendations.Add(new ProductRecommendation
                {
                    Product = candidate,
                    Score = score,
                    Reason = await GenerateRecommendationReasonAsync(baseProduct, candidate, score)
                });
            }
        }

        return recommendations
            .OrderByDescending(r => r.Score)
            .Take(limit)
            .ToList();
    }

    private async Task<string> GenerateRecommendationReasonAsync(
        Product baseProduct, Product candidate, int score)
    {
        var prompt = $@"
        Explica brevemente por qu√© recomendamos {candidate.Brand} {candidate.Model} 
        para un cliente interesado en {baseProduct.Brand} {baseProduct.Model}.
        
        Calificaci√≥n: {score}/100
        
        Proporciona una explicaci√≥n de m√°ximo 2 l√≠neas, enfoc√°ndote en los beneficios principales.
        ";

        var response = await _openAI.GenerateCompletionAsync(prompt, new
        {
            MaxTokens = 50,
            Temperature = 0.7
        });

        return response.Text.Trim();
    }
}
```

---

## API de Gesti√≥n de Inventario

### Controlador de Inventario

```csharp
[ApiController]
[Route("api/v1/inventory")]
[Authorize]
public class InventoryController : ControllerBase
{
    private readonly IInventoryService _inventoryService;
    private readonly IInventoryAgent _inventoryAgent;

    /// <summary>
    /// Obtener niveles de inventario con predicciones AI
    /// </summary>
    [HttpGet("levels")]
    [SwaggerOperation(Summary = "Obtener niveles de inventario con an√°lisis AI")]
    [SwaggerResponse(200, "Niveles de inventario", typeof(List<InventoryLevelDto>))]
    public async Task<ActionResult<List<InventoryLevelDto>>> GetInventoryLevelsAsync(
        [FromQuery] string? warehouse = null,
        [FromQuery] string? category = null,
        [FromQuery] bool includePredictions = true)
    {
        var levels = await _inventoryService.GetInventoryLevelsAsync(warehouse, category);
        
        if (includePredictions)
        {
            // Enriquecer con predicciones de AI
            foreach (var level in levels)
            {
                level.Predictions = await _inventoryAgent.GetDemandPredictionAsync(
                    level.ProductId, 30); // 30 d√≠as
                level.RecommendedActions = await _inventoryAgent.GetRecommendedActionsAsync(
                    level.ProductId, level.CurrentStock);
            }
        }
        
        return Ok(levels);
    }

    /// <summary>
    /// Obtener alertas de inventario generadas por AI
    /// </summary>
    [HttpGet("alerts")]
    [SwaggerOperation(Summary = "Obtener alertas de inventario del agente AI")]
    [SwaggerResponse(200, "Alertas de inventario", typeof(List<InventoryAlertDto>))]
    public async Task<ActionResult<List<InventoryAlertDto>>> GetInventoryAlertsAsync(
        [FromQuery] AlertSeverity? severity = null,
        [FromQuery] int limit = 50)
    {
        var alerts = await _inventoryAgent.GetActiveAlertsAsync(severity, limit);
        var response = alerts.Select(a => new InventoryAlertDto
        {
            Id = a.Id,
            ProductId = a.ProductId,
            ProductName = a.ProductName,
            AlertType = a.AlertType,
            Severity = a.Severity,
            Message = a.Message,
            RecommendedAction = a.RecommendedAction,
            CreatedAt = a.CreatedAt,
            EstimatedImpact = a.EstimatedImpact
        }).ToList();
        
        return Ok(response);
    }

    /// <summary>
    /// Ejecutar optimizaci√≥n de inventario con AI
    /// </summary>
    [HttpPost("optimize")]
    [SwaggerOperation(Summary = "Ejecutar optimizaci√≥n autom√°tica de inventario")]
    [SwaggerResponse(200, "Resultado de optimizaci√≥n", typeof(OptimizationResultDto))]
    public async Task<ActionResult<OptimizationResultDto>> OptimizeInventoryAsync(
        [FromBody] OptimizationRequest request)
    {
        try
        {
            var result = await _inventoryAgent.OptimizeInventoryAsync(request);
            
            // Log de la operaci√≥n para auditoria
            _logger.LogInformation(
                "Optimizaci√≥n de inventario ejecutada. Productos: {ProductCount}, " +
                "Ahorro estimado: {Savings}, Usuario: {UserId}",
                result.ProcessedProducts.Count,
                result.EstimatedSavings,
                User.Identity?.Name);
            
            return Ok(new OptimizationResultDto
            {
                ProcessedProducts = result.ProcessedProducts.Count,
                GeneratedOrders = result.GeneratedOrders.Count,
                EstimatedSavings = result.EstimatedSavings,
                EstimatedROI = result.EstimatedROI,
                RecommendedActions = result.RecommendedActions,
                ExecutionTime = result.ExecutionTime
            });
        }
        catch (OptimizationException ex)
        {
            _logger.LogError(ex, "Error during inventory optimization");
            return BadRequest(new { Error = "Optimization failed", Details = ex.Message });
        }
    }
}
```

---

## API de Gesti√≥n de Pedidos

### Controlador de Pedidos

```csharp
[ApiController]
[Route("api/v1/orders")]
[Authorize]
public class OrdersController : ControllerBase
{
    private readonly IOrderService _orderService;
    private readonly ILogisticsAgent _logisticsAgent;

    /// <summary>
    /// Crear pedido con optimizaci√≥n autom√°tica
    /// </summary>
    [HttpPost]
    [SwaggerOperation(Summary = "Crear nuevo pedido con optimizaci√≥n AI")]
    [SwaggerResponse(201, "Pedido creado", typeof(OrderResponseDto))]
    [SwaggerResponse(400, "Datos inv√°lidos")]
    public async Task<ActionResult<OrderResponseDto>> CreateOrderAsync(
        [FromBody] CreateOrderRequest request)
    {
        try
        {
            // Validaci√≥n b√°sica
            var validationResult = await _orderService.ValidateOrderAsync(request);
            if (!validationResult.IsValid)
            {
                return BadRequest(validationResult.Errors);
            }

            // Optimizar pedido con AI (precios, descuentos, rutas)
            var optimizedOrder = await _logisticsAgent.OptimizeOrderAsync(request);
            
            // Crear pedido
            var order = await _orderService.CreateOrderAsync(optimizedOrder);
            
            // Programar entrega autom√°ticamente
            var deliverySchedule = await _logisticsAgent.ScheduleDeliveryAsync(order.Id);
            
            var response = new OrderResponseDto
            {
                OrderId = order.Id,
                OrderNumber = order.OrderNumber,
                CustomerId = order.CustomerId,
                Items = order.Items.Select(i => new OrderItemDto
                {
                    ProductId = i.ProductId,
                    ProductName = i.ProductName,
                    Quantity = i.Quantity,
                    UnitPrice = i.UnitPrice,
                    TotalPrice = i.TotalPrice,
                    Discount = i.Discount
                }).ToList(),
                Subtotal = order.Subtotal,
                Tax = order.Tax,
                Total = order.Total,
                EstimatedDelivery = deliverySchedule.EstimatedDelivery,
                TrackingNumber = deliverySchedule.TrackingNumber,
                Status = order.Status,
                CreatedAt = order.CreatedAt,
                OptimizationSavings = optimizedOrder.AppliedSavings
            };
            
            return CreatedAtAction(nameof(GetOrderAsync), new { orderId = order.Id }, response);
        }
        catch (InsufficientInventoryException ex)
        {
            return BadRequest(new { Error = "Insufficient inventory", Details = ex.Message });
        }
        catch (OptimizationException ex)
        {
            _logger.LogWarning(ex, "Order optimization failed, proceeding with standard pricing");
            
            // Fallback a proceso est√°ndar si la optimizaci√≥n falla
            var standardOrder = await _orderService.CreateOrderAsync(request);
            var response = _mapper.Map<OrderResponseDto>(standardOrder);
            
            return CreatedAtAction(nameof(GetOrderAsync), new { orderId = standardOrder.Id }, response);
        }
    }

    /// <summary>
    /// Obtener tracking en tiempo real
    /// </summary>
    [HttpGet("{orderId}/tracking")]
    [SwaggerOperation(Summary = "Obtener informaci√≥n de tracking en tiempo real")]
    [SwaggerResponse(200, "Informaci√≥n de tracking", typeof(TrackingInfoDto))]
    public async Task<ActionResult<TrackingInfoDto>> GetTrackingInfoAsync(string orderId)
    {
        var order = await _orderService.GetOrderAsync(orderId);
        if (order == null)
        {
            return NotFound();
        }

        var trackingInfo = await _logisticsAgent.GetRealTimeTrackingAsync(orderId);
        
        return Ok(new TrackingInfoDto
        {
            OrderId = orderId,
            Status = trackingInfo.Status,
            CurrentLocation = trackingInfo.CurrentLocation,
            EstimatedArrival = trackingInfo.EstimatedArrival,
            DeliveryRoute = trackingInfo.Route,
            LastUpdate = trackingInfo.LastUpdate,
            DriverInfo = trackingInfo.DriverInfo,
            DeliveryInstructions = trackingInfo.DeliveryInstructions
        });
    }
}
```

---

## Configuraci√≥n de Azure API Management

### Policies de Seguridad y Rate Limiting

```xml
<policies>
    <inbound>
        <!-- Validaci√≥n de JWT Token -->
        <validate-jwt header-name="Authorization" failed-validation-httpcode="401" 
                      failed-validation-error-message="Unauthorized. Access token is missing or invalid.">
            <openid-config url="https://login.microsoftonline.com/{{tenant-id}}/v2.0/.well-known/openid_configuration" />
            <required-claims>
                <claim name="aud" match="any">
                    <value>{{client-id}}</value>
                </claim>
                <claim name="scp" match="any">
                    <value>api.read</value>
                    <value>api.write</value>
                </claim>
            </required-claims>
        </validate-jwt>
        
        <!-- Rate Limiting por cliente -->
        <rate-limit-by-key calls="1000" renewal-period="3600" 
                           counter-key="@(context.Request.IpAddress)" />
        
        <!-- Rate Limiting por subscription -->
        <quota-by-subscription-key calls="10000" renewal-period="86400" />
        
        <!-- Throttling para proteger backend -->
        <throttle-by-key calls="100" renewal-period="60" 
                         counter-key="@(context.Subscription.Id)" />
        
        <!-- Logging de requests -->
        <log-to-eventhub logger-id="{{logger-id}}">
            @{
                return new JObject(
                    new JProperty("EventTime", DateTime.UtcNow.ToString()),
                    new JProperty("ServiceName", context.Deployment.ServiceName),
                    new JProperty("RequestId", context.RequestId),
                    new JProperty("RequestIp", context.Request.IpAddress),
                    new JProperty("OperationName", context.Operation.Name)
                ).ToString();
            }
        </log-to-eventhub>
    </inbound>
    
    <backend>
        <!-- Circuit Breaker Pattern -->
        <retry condition="@(context.Response.StatusCode >= 500)" count="3" interval="1">
            <forward-request />
        </retry>
    </backend>
    
    <outbound>
        <!-- Cache de respuestas -->
        <cache-store duration="300" 
                     vary-by-developer="true" 
                     vary-by-developer-groups="true" />
        
        <!-- Headers de CORS -->
        <cors allow-credentials="true">
            <allowed-origins>
                <origin>https://topllantas.com</origin>
                <origin>https://app.topllantas.com</origin>
            </allowed-origins>
            <allowed-methods>
                <method>GET</method>
                <method>POST</method>
                <method>PUT</method>
                <method>DELETE</method>
            </allowed-methods>
            <allowed-headers>
                <header>*</header>
            </allowed-headers>
        </cors>
        
        <!-- Headers de seguridad -->
        <set-header name="X-Content-Type-Options" exists-action="override">
            <value>nosniff</value>
        </set-header>
        <set-header name="X-Frame-Options" exists-action="override">
            <value>DENY</value>
        </set-header>
        <set-header name="X-XSS-Protection" exists-action="override">
            <value>1; mode=block</value>
        </set-header>
    </outbound>
    
    <on-error>
        <set-status code="500" reason="Internal Server Error" />
        <set-body>@{
            return new JObject(
                new JProperty("error", new JObject(
                    new JProperty("code", "InternalError"),
                    new JProperty("message", "An internal error occurred"),
                    new JProperty("requestId", context.RequestId)
                ))
            ).ToString();
        }</set-body>
    </on-error>
</policies>
```

---

## Monitoreo y Observabilidad

### Application Insights Integration

```csharp
public class TelemetryService : ITelemetryService
{
    private readonly TelemetryClient _telemetryClient;
    
    public void TrackAPICall(string operationName, TimeSpan duration, bool success, 
                           Dictionary<string, string>? properties = null)
    {
        var telemetry = new DependencyTelemetry
        {
            Name = operationName,
            Duration = duration,
            Success = success,
            Type = "HTTP"
        };
        
        if (properties != null)
        {
            foreach (var prop in properties)
            {
                telemetry.Properties.Add(prop.Key, prop.Value);
            }
        }
        
        _telemetryClient.TrackDependency(telemetry);
    }
    
    public void TrackBusinessMetric(string metricName, double value, 
                                  Dictionary<string, string>? properties = null)
    {
        _telemetryClient.TrackMetric(metricName, value, properties);
    }
    
    public void TrackAPIError(Exception exception, string operationName, 
                            Dictionary<string, string>? properties = null)
    {
        var telemetry = new ExceptionTelemetry(exception)
        {
            SeverityLevel = SeverityLevel.Error
        };
        
        telemetry.Properties.Add("OperationName", operationName);
        
        if (properties != null)
        {
            foreach (var prop in properties)
            {
                telemetry.Properties.Add(prop.Key, prop.Value);
            }
        }
        
        _telemetryClient.TrackException(telemetry);
    }
}
```

### M√©tricas Personalizadas

```csharp
public class APIMetricsMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ITelemetryService _telemetry;
    private readonly ILogger<APIMetricsMiddleware> _logger;

    public APIMetricsMiddleware(RequestDelegate next, ITelemetryService telemetry, 
                               ILogger<APIMetricsMiddleware> logger)
    {
        _next = next;
        _telemetry = telemetry;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();
        var operationName = $"{context.Request.Method} {context.Request.Path}";
        
        try
        {
            await _next(context);
            
            stopwatch.Stop();
            
            var properties = new Dictionary<string, string>
            {
                ["Method"] = context.Request.Method,
                ["Path"] = context.Request.Path,
                ["StatusCode"] = context.Response.StatusCode.ToString(),
                ["UserAgent"] = context.Request.Headers["User-Agent"].ToString(),
                ["UserId"] = context.User?.Identity?.Name ?? "Anonymous"
            };
            
            _telemetry.TrackAPICall(
                operationName, 
                stopwatch.Elapsed, 
                context.Response.StatusCode < 400, 
                properties);
                
            // M√©tricas de negocio espec√≠ficas
            TrackBusinessMetrics(context, stopwatch.Elapsed);
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            
            _telemetry.TrackAPIError(ex, operationName, new Dictionary<string, string>
            {
                ["Method"] = context.Request.Method,
                ["Path"] = context.Request.Path,
                ["Duration"] = stopwatch.ElapsedMilliseconds.ToString()
            });
            
            throw;
        }
    }
    
    private void TrackBusinessMetrics(HttpContext context, TimeSpan duration)
    {
        // M√©tricas espec√≠ficas del negocio
        if (context.Request.Path.StartsWithSegments("/api/v1/orders"))
        {
            _telemetry.TrackBusinessMetric("orders.api.response_time", 
                                         duration.TotalMilliseconds);
        }
        
        if (context.Request.Path.StartsWithSegments("/api/v1/inventory"))
        {
            _telemetry.TrackBusinessMetric("inventory.api.response_time", 
                                         duration.TotalMilliseconds);
        }
        
        // Contadores de uso por endpoint
        _telemetry.TrackBusinessMetric($"api.endpoint.{context.Request.Path}.calls", 1);
    }
}
```

---

## Conclusi√≥n

Este plan de implementaci√≥n de APIs proporciona una base s√≥lida para la integraci√≥n entre el ERP existente de TopLlantas y la nueva plataforma de agentes de AI. La arquitectura de microservicios, combinada con Azure API Management y las mejores pr√°cticas de seguridad, garantiza escalabilidad, confiabilidad y mantenibilidad a largo plazo.

Las APIs est√°n dise√±adas para ser:
- **Seguras**: Con autenticaci√≥n OAuth 2.0 y autorizaci√≥n granular
- **Escalables**: Con rate limiting y caching inteligente
- **Resilientes**: Con circuit breakers y retry policies
- **Observables**: Con logging y m√©tricas comprehensivas
- **Documentadas**: Con OpenAPI/Swagger completo
